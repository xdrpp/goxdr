.\" Automatically generated by Pandoc 3.1.12.1
.\"
.TH "goxdr" "1" "" "" ""
.SH NAME
goxdr \- Go XDR compiler
.SH SYNOPSIS
goxdr [\-b|\-B] [\-fmt] [\-i \f[I]import\f[R]] [\-p \f[I]package\f[R]]
.PD 0
.P
.PD
\ \ \ \ \ \ [\-o \f[I]output.go\f[R]] [\f[I]file.x\f[R] \&...]
.SH DESCRIPTION
goxdr compiles an RFC4506 XDR interface file to a set of go data
structures that can be either marshaled to or unmarshaled from standard
XDR binary format or traversed for other purposes such as
pretty\-printing.
It does not rely on go\[cq]s reflection facilities, and so can be used
to special\-case handling of different XDR typedefs that represent
identical go types.
.PP
Because go\[cq]s type system is not very extensible, goxdr uses a
\f[I]dual type system\f[R].
Every type \f[CR]T\f[R] declared in an XDR file compiles to two
corresponding go types, a \f[I]native type\f[R] \f[CR]T\f[R] convenient
for programming, and an \f[I]XdrType\f[R], \f[CR]XdrType_T\f[R], with
methods that facilitate generic traversal and marshaling.
\f[CR]XdrType_T\f[R] is equivalent to \f[CR]*T\f[R] when it is possible
to implement appropriate methods on \f[CR]T\f[R], but this is not always
the case.
However, for all XDR types \f[CR]T\f[R], there is a method
\f[CR]XDR_T(*T)XdrType_T\f[R] to cast a value to its XdrType.
.PP
goxdr\[cq]s native types map to the most intuitive go equivalent:
strings map to strings, pointers map to pointers, fixed\-size arrays map
to arrays, and variable\-length arrays map to slices, without new type
declarations that might complicate assignment.
E.g., the XDR \f[CR]typedef string mystring<32>\f[R] is just a string,
and so can be assigned from a string.
This does mean you can assign a string longer than 32 bytes, but length
limits are enforced during both marshaling and unmarshaling.
.SS Type representations
To be consistent with go\[cq]s symbol export policy, all types, enum
constants, and struct/union fields defined in an XDR file are
capitalized in the corresponding go representation.
Source XDR types are mapped to their equivalent go types as follows
(note that \f[CR]T\f[R] cannot be \f[CR]opaque\f[R] or \f[CR]string\f[R]
in this table):
.IP
.EX
Source type     Native type    notes
\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-   \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
bool            bool           use capital TRUE and FALSE
int             int32
unsigned int    uint32
hyper           int64
unsigned hyper  uint64
float           float32
double          float64
quadruple       float128       but float128 is not defined
string<n>       string
opaque<n>       []byte
opaque[n]       [n]byte
enum T          type T int32
T*              *T             for any XDR type T
T<n>            []T            for any XDR type T
T[n]            [n]T           for any XDR type T
.EE
.PP
Each XDR \f[CR]typedef\f[R] is compiled to a go type alias
(\f[CR]type Alias = Original\f[R]).
However, each has its own XdrType, allowing generic traversal code to
special\-case the use of type aliases.
Among other places, this is useful for pretty\-printing code that
displays the same underlying type in different ways.
For example, if your XDR source specifies:
.IP
.EX
\f[B]typedef\f[R] int meters;
\f[B]typedef\f[R] int seconds;
.EE
.PP
it will compile to native types:
.IP
.EX
\f[B]type\f[R] Meters = int32
\f[B]type\f[R] Seconds = int32
.EE
.PP
But you can treat instances of each specially in your marshaling
function by testing for type \f[CR]XdrType_Meters\f[R] or
\f[CR]XdrType_Seconds\f[R].
Alternatively, you can also use the \f[CR]XdrTypeName()string\f[R]
method to obtain the string \[lq]Meters\[rq] or \[lq]Seconds.\[rq]
.PP
Each XDR \f[CR]enum\f[R] declaration compiles to a defined type whose
representation is an \f[CR]int32\f[R].
The constants of the enum are defined as go constants of the new defined
type.
.PP
RFC4506 defines \f[CR]bool\f[R] in XDR source as equivalent to an
\f[CR]enum\f[R] with name identifiers \f[CR]TRUE\f[R] and
\f[CR]FALSE\f[R].
goxdr translates XDR\[cq]s \f[CR]bool\f[R] to go\[cq]s native
\f[CR]bool\f[R] type.
However, following the RFC, goxdr still requires you to use capital
\f[CR]TRUE\f[R] and \f[CR]FALSE\f[R].
(The identifiers \f[CR]true\f[R] and \f[CR]false\f[R] will get
translated to exported go identifiers \f[CR]True\f[R] and
\f[CR]False\f[R], which is probably not what you want.)
.PP
An XDR \f[CR]struct\f[R] is compiled to a defined type represented as a
go struct containing each field of the XDR struct.
.PP
An XDR \f[CR]union\f[R] is compiled to a data structure with one public
field for the discriminant and one method for each non\-void \[lq]arm
declaration\[rq] (i.e., declaration in a case statement) that returns a
pointer to a value of the appropriate type.
There is no need to initialize the union when setting the discriminant;
changing its value just causes the appropriate method to return a
non\-nil pointer.
Invoking the wrong method for the current discriminant value calls
panic.
.PP
As an example, the following XDR source:
.IP
.EX
\f[B]enum\f[R] myenum {
    tag1 = 1,
    tag2 = 2,
    tag3 = 3
};

\f[B]union\f[R] myunion \f[B]switch\f[R] (myenum discriminant) {
    \f[B]case\f[R] tag1:
        int one;
    \f[B]case\f[R] tag2:
        string two<>;
    \f[B]default\f[R]:
        void;
};
.EE
.PP
compiles to this go code:
.IP
.EX
\f[B]type\f[R] Myenum int32
\f[B]const\f[R] (
    Tag1 Myenum = 1
    Tag2 Myenum = 2
    Tag3 Myenum = 3
)
\f[B]func\f[R] XDR_Myenum(v *Myenum) *Myenum { \f[B]return\f[R] v }

\f[B]type\f[R] Myunion \f[B]struct\f[R] {
    Discriminant Myenum
    ...
}
\f[B]func\f[R] (u *Myunion) One() *int32 {...}
\f[B]func\f[R] (u *Myunion) Two() *string {...}
\f[B]func\f[R] XDR_Myunion(x XDR) *Myunion { \f[B]return\f[R] v }
.EE
.SS Convenience methods
XDR \f[CR]union\f[R] types have an \f[CR]XdrValid() bool\f[R] method
that returns whether the discriminant is in a valid state.
If the \f[CR]union\f[R] type does not have a default case, another
method \f[CR]XdrValidTags() map[uint32]bool\f[R] specifies the set of
valid discriminant values.
For \f[CR]union\f[R] types that are not valid by default, because
go\[cq]s default 0 value does not correspond to a valid discriminant, a
method \f[CR]XdrInitialize()\f[R] places them in a valid state.
Similarly, \f[CR]enum\f[R] types that can\[cq]t be statically verified
to be valid with value 0 (either because no name is assigned to constant
0, or because names are assigned to constants in a different file), have
an \f[CR]XdrInitialize()\f[R] method that sets them to the first name in
the \f[CR]enum\f[R] definition.
.SS The XDR interface
As previously mentioned, for every native type \f[CR]T\f[R] generated by
goxdr (where \f[CR]T\f[R] is the capitalized go type), including
typedefs, there is a corresponding XdrType into which one can cast the
native type by means of a generated function:
.IP
.EX
\f[B]func\f[R] XDR_T(v *T) XdrType_T {...}
.EE
.PP
All XdrTypes support the \f[CR]XdrType\f[R] interface:
.IP
.EX
\f[B]type\f[R] XdrType \f[B]interface\f[R] {
    XdrTypeName() string
    XdrValue() \f[B]interface\f[R]{}
    XdrPointer() \f[B]interface\f[R]{}
    XdrMarshal(XDR, string)
}
.EE
.PP
The XdrType can be marshaled, unmarshaled, or otherwise traversed by
means of the \f[CR]XdrMarshal(x XDR, name string)\f[R] method.
Note the \f[CR]name\f[R] argument has no effect for RFC4506\-compliant
binary marshaling, and can safely be supplied as the empty string
\f[CR]\[dq]\[dq]\f[R].
However, when traversing an XDR type for other purposes such as
pretty\-printing, \f[CR]name\f[R] will be set to the nested name of the
field (with components separated by period).
.PP
The argument \f[CR]x\f[R] implements the XDR interface and determines
what XDR_T actually does (i.e., marshal or unmarshal).
It has the following interface:
.IP
.EX
\f[B]type\f[R] XDR \f[B]interface\f[R] {
    Marshal(name string, val XdrType)
    Sprintf(string, ...\f[B]interface\f[R]{}) string
}
.EE
.PP
\f[CR]Sprintf\f[R] is expected to be a copy of \f[CR]fmt.Sprintf\f[R].
However, XDR back\-ends that do not make use of the \f[CR]name\f[R]
argument (notably marshaling to RFC4506 binary format) can save some
overhead by returning an empty string.
Hence, the two sensible implementations of \f[CR]Sprintf\f[R] are:
.IP
.EX
\f[B]func\f[R] (xp *MyXDR1) Sprintf(f string, args ...\f[B]interface\f[R]{}) string {
    \f[B]return\f[R] fmt.Sprintf(f, args...)
}

\f[B]func\f[R] (xp *MyXDR2) Sprintf(f string, args ...\f[B]interface\f[R]{}) string {
    \f[B]return\f[R] \[dq]\[dq]
}
.EE
.PP
\f[CR]Marshal\f[R] is the method that actually does whatever work will
be applied to the data structure.
The second argument, \f[CR]val\f[R], will be the go value that must be
marshaled/unmarshaled.
To simplify data structure traversal, XdrTypes implement various more
specific interfaces that extend \f[CR]XdrType\f[R] allowing many
different types to be handled identically.
Specifically:
.IP \[bu] 2
For bool and all 32\-bit numeric types (including the size of
variable\-length arrays), The XdrType implements \f[CR]XdrNum32\f[R],
which allows the value to be extracted and set as a \f[CR]uint32\f[R].
.IP \[bu] 2
For all 64\-bit numeric types, the XdrType imlements
\f[CR]XdrNum64\f[R], which allows the value to be extracted and set as a
\f[CR]uint64\f[R].
.IP \[bu] 2
For \f[CR]struct\f[R] and \f[CR]union\f[R] types, the XdrType is just a
pointer to the type being marshaled.
However, these types implement the \f[CR]XdrAggregate\f[R] interface,
which extends \f[CR]XdrType\f[R] with the method
\f[CR]XdrRecurse(x XDR, name string)\f[R] that recursively marshals
every field of the type.
\f[CR]union\f[R] types also implement the \f[CR]XdrUnion\f[R] interface.
.IP \[bu] 2
An \f[CR]enum\f[R] type \f[CR]T\f[R] also just uses \f[CR]*T\f[R] as its
XdrType, but \f[CR]enum\f[R] types implement \f[CR]XdrNum32\f[R] instead
of \f[CR]XdrAggregate\f[R].
They also implement the \f[CR]XdrEnum\f[R] interface, which provides
access to symbolic names via the
\f[CR]XdrEnumNames() map[int32]string\f[R] method.
.IP \[bu] 2
Fixed\-length arrays (other than \f[CR]opaque[]\f[R]) have a generated
XdrType that implements the \f[CR]XdrArray\f[R] interface, which extends
\f[CR]XdrAggregate\f[R].
Calling \f[CR]XdrRecurse\f[R] on an array iterates over the array to
marshal each element individually.
.IP \[bu] 2
Variable\-length arrays (other than \f[CR]opaque<>\f[R]) also use a
generated XdrType implementing the \f[CR]XdrVec\f[R] interface, which
also extends \f[CR]XdrAggregate\f[R].
The \f[CR]XdrRecurse\f[R] method first calls \f[CR]Marshal\f[R] on a
value of \f[CR]XdrSize\f[R] to get or set the size of the array, then
calls \f[CR]Marshal\f[R] on each element of the array as with
fixed\-length arrays.
.IP \[bu] 2
Similar to variable\-length arrays, pointers use a generated XdrType
that implements the \f[CR]XdrPtr\f[R] interface, which extends
\f[CR]XdrAggregate\f[R].
The \f[CR]XdrRecurse\f[R] method first calls \f[CR]Marshal\f[R] on
another generated type that implements the \f[CR]XdrNum32\f[R] interface
(capable of containing the value 0 or 1 to indicate nil or
value\-present), then, if the pointer is non\-nil, it calls
\f[CR]Marshal\f[R] on the underlying value.
.IP \[bu] 2
\f[CR]string\f[R] has \f[CR]XdrType\f[R] of \f[CR]XdrString\f[R], which
also encodes the size bound of the string and implements the
\f[CR]XdrVarBytes\f[R] and \f[CR]XdrBytes\f[R] interfaces that extend
\f[CR]XdrType\f[R].
.IP \[bu] 2
\f[CR]opaque<>\f[R] has an \f[CR]XdrType\f[R] of
\f[CR]XdrVecOpaque\f[R], which also implements the
\f[CR]XdrVarBytes\f[R] and \f[CR]XdrBytes\f[R] interfaces that extend
\f[CR]XdrType\f[R].
.IP \[bu] 2
\f[CR]opaque[]\f[R] is passed as a generated type implementing
\f[CR]XdrArrayOpaque\f[R], which extends \f[CR]XdrBytes\f[R] but not
\f[CR]XdrVarBytes\f[R].
.PP
For most types, you can recover the native type from the XdrType via the
the \f[CR]XdrPointer()\f[R] and \f[CR]XdrValue()\f[R] methods, which
return an \f[CR]interface{}\f[R].
One exception is arrays (including \f[CR]opaque[]\f[R]), for which
\f[CR]XdrValue()\f[R] returns a slice to avoid copying the entire array.
Also, the fake \f[CR]bool\f[R] on which \f[CR]Marshal\f[R] is called for
a pointer type supports \f[CR]XdrValue()\f[R] but returns \f[CR]nil\f[R]
from \f[CR]XdrPointer()\f[R] since there is no actual \f[CR]bool\f[R] to
point to.
.PP
The \f[CR]XdrTypeName()\f[R] method returns a string describing the
underlying type as declared in the XDR file, including any
\f[CR]typedef\f[R] aliases used.
The string returned may have a suffix of
\[lq]*\[lq],\[rq]?\[lq],\[rq]<>\[lq], or\[rq][]\[rq] to indicate
pointers, the boolean associated with a pointer, a variable\-length
array, and a fixed\-length array, respectively.
If you want the actual size or bound that would go inside the
\[lq][]\[rq] or \[lq]<>\[rq], you will need to obtain these from the
\f[CR]XdrArraySize()uint32\f[R] or \f[CR]XdrBound()uint32\f[R] method
respectively.
.PP
The table below summarizes the (overlapping) interfaces implemented by
the the different XdrTypes generated.
In the table, \f[CR]T\f[R] stands for a complete standalone XDR type (so
not \f[CR]string\f[R] or \f[CR]opaque\f[R]).
Basic marshaling can be performed in a type switch statement handling
interfaces that cover all types, for instance \f[CR]XdrNum32\f[R],
\f[CR]XdrNum64\f[R], \f[CR]XdrBytes\f[R], and \f[CR]XdrAggregate\f[R].
.IP
.EX
Interface       Implemented for XDR source types
\-\-\-\-\-\-\-\-\-\-\-     \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
XdrNum32        bool, [unsigned] int, enums, float,
                size, pointer present flag
XdrNum64        [unsigned] hyper, double
XdrArray        T[n]
XdrVec          T<n>
XdrPtr          T*
XdrEnum         enum T
XdrUnion        union T
XdrBytes        string<n>, opaque[n], opaque<n>
XdrVarBytes     string<n>, opaque<n>
XdrArrayOpaque  opaque[n]
XdrAggregate    struct T, union T, T*, T<n>, T[n]
XdrTypedef      typedef BaseT T
fmt.Stringer    all types in XdrNum{32,64} and XdrBytes
fmt.Scanner     all types in XdrNum{32,64} and XdrBytes
XdrType         all XDR types
.EE
.SS XDR functions
As previously mentioned, each (capitalized) type \f[CR]T\f[R] output by
goxdr also has function \f[CR]XDR_T\f[R] that returns an instance of
\f[CR]XdrType\f[R].
For \f[CR]struct\f[R], \f[CR]union\f[R], and \f[CR]enum\f[R] types, this
function is the identity function:
.IP
.EX
\f[B]func\f[R] XDR_T(v *T) XdrType_T { \f[B]return\f[R] v }
.EE
.PP
For other types, however, this returns a defined type implementing the
interfaces described in the previous subsection.
As an example, the following function in the pre\-defined boilerplate
casts an ordinary \f[CR]*int32\f[R] into the defined type
\f[CR]*XdrInt32\f[R], which implements the \f[CR]XdrNum32\f[R]
interface:
.IP
.EX
\f[B]type\f[R] XdrInt32 int32
\f[B]type\f[R] XdrType_int32 = *XdrInt32
\f[I]// ... implementation of XdrNum32 methods ...\f[R]
\f[B]func\f[R] (XdrInt32) XdrTypeName() string { \f[B]return\f[R] \[dq]int32\[dq] }
\f[B]func\f[R] (v *XdrInt32) XdrPointer() \f[B]interface\f[R]{} { \f[B]return\f[R] (*int32)(v) }
\f[B]func\f[R] (v XdrInt32) XdrValue() \f[B]interface\f[R]{} { \f[B]return\f[R] int32(v) }
\f[B]func\f[R] (v *XdrInt32) XdrMarshal(x XDR, name string) { x.Marshal(name, v) }
\f[B]func\f[R] XDR_int32(v *int32) *XdrInt32 { \f[B]return\f[R] (*XdrInt32)(v) }
.EE
.PP
The following table lists the concrete types passed to the
\f[CR]Marshal\f[R] method.
Note that types listed as \f[CR]generated\f[R] get passed as a different
defined type for each underlying type \f[CR]T\f[R].
The defined type makes the size bound availble via an
\f[CR]XdrBound()\f[R] method, since that information cannot conveniently
be encoded as part of the go type.
.IP
.EX
XDR type        Marshaled as    notes
\-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
bool            *XdrBool
int             *XdrInt32
unsigned int    *XdrUint32
float           *XdrFloat32
hyper           *XdrInt64
unsigned hyper  *XdrUint64
double          *XdrFloat64
string<n>       XdrString
opaque<n>       XdrVecOpaque
opaque[n]       generated
T               *T              for struct, enum, union
T[n]            generated
T*              generated
T<n>            generated
size            *XdrSize        when recursing in T<n>
typedef         generated       XdrBaseType(v) gives inner type
.EE
.PP
Note that an XDR \f[CR]Marshal(name string, v XdrType)\f[R] method can
use a type switch to special\-case certain interfaces and types.
If you test \f[CR]v\f[R] against interfaces (e.g., \f[CR]XdrNum32\f[R]),
it will work regardless of typedefs.
If you test \f[CR]v\f[R] for specific types, such as
\f[CR]XdrString\f[R] or \f[CR]XdrType_int32\f[R], it will not work for
typedefs.
You can, however, switch on \f[CR]XdrBaseType(v)\f[R] to check the
underlying base type.
You can also, of course, switch on the native type returned by
v.XdrPointer(), which is not affected by typedefs.
\f[CR]XdrTypeName()\f[R] is also useful to check for typedefs, but to do
so should be called on \f[CR]v\f[R] rather than
\f[CR]XdrBaseType(v)\f[R].
.PP
\f[CR]XdrMarshal\f[R] methods panic with type \f[CR]XdrError\f[R] (a
user\-defined string) if the input is invalid or a value is out of
range.
.SS Pre\-defined XDR types
The types \f[CR]XdrOut\f[R], \f[CR]XdrIn\f[R], and \f[CR]XdrPrint\f[R]
in the boilerplate code (by default package
\f[CR]\[dq]github.com/xdrpp/goxdr/xdr\[dq]\f[R]) implement the
\f[CR]XDR\f[R] interface and perform RFC4506 binary marshaling, RFC4506
binary unmarshaling, and pretty\-printing, respectively.
.IP
.EX
\f[B]type\f[R] XdrOut \f[B]struct\f[R] {
    Out io.Writer
}
\f[B]type\f[R] XdrIn \f[B]struct\f[R] {
    In io.Reader
}
\f[B]type\f[R] XdrPrint \f[B]struct\f[R] {
    Out io.Writer
}
.EE
.SS Program and version declarations
Each version declaration inside a program declaration gets compiled down
to an interface with the same name as the version.
For example this declaration
.IP
.EX
program my_prog {
  version my_vers {
    void null(void) = 1;
    int Increment(int) = 2;
    void MultiArg(int, int) = 3;
  } = 1;
} = 0x20000000;
.EE
.PP
yields the following interface:
.IP
.EX
\f[B]type\f[R] My_vers \f[B]interface\f[R] {
    Null()
    Increment(*int32) *int32
    MultiArg(*int32, *int32)
}
.EE
.PP
In addition, goxdr creates a type that implements the \f[CR]My_vers\f[R]
interface (for use in clients):
.IP
.EX
\f[B]type\f[R] My_vers_Client \f[B]struct\f[R] {
    XdrSend \f[B]func\f[R](XdrProc) error
}
\f[B]func\f[R] (c My_vers_Client) Null() {...}
\f[B]func\f[R] (c My_vers_Client) Increment(a1 *int32) *int32 {...}
\f[B]func\f[R] (c My_vers_Client) MultiArg(a1 *int32, a2 *int32) {...}
.EE
.PP
The methods all bundle their argument and result types into a type
implementing \f[CR]XdrProc\f[R], and pass it to a function
\f[CR]XdrSend\f[R].
An \f[CR]XdrProc\f[R] instance contains all the information necessary to
marshal a remote procedure call and its result, namely the program,
version, and procedure numbers as well as both the arguments and results
ready to be marshaled in \f[CR]XdrType\f[R] format.
\f[CR]GetArg()\f[R] returns the arguments supplied by the user, while
\f[CR]GetRes()\f[R] returns a result type expected to be overwritten by
the result of the RPC.
.IP
.EX
\f[B]type\f[R] XdrProc \f[B]interface\f[R] {
    Prog() uint32
    Vers() uint32
    Proc() uint32
    ProgName() string
    VersName() string
    ProcName() string
    GetArg() XdrType
    GetRes() XdrType
}
.EE
.PP
For the server side, goxdr generates a type \f[CR]My_vers_Server\f[R]
that takes an instance of \f[CR]My_vers\f[R] and allows lookup of
argument and result types by procedure number.
Specifically, \f[CR]My_vers_Server\f[R] just requires an instance of
\f[CR]My_vers\f[R], and then generically exposes it through the
\f[CR]XdrSrv\f[R] interface.
.IP
.EX
\f[B]type\f[R] My_vers_Server \f[B]struct\f[R] {
    Srv My_vers
}
\f[B]func\f[R] (s My_vers_Server) GetProc(p uint32) XdrSrvProc {...}
\f[B]var\f[R] _ XdrSrv = My_vers_Server{}    \f[I]// implements XdrSrv interface\f[R]
.EE
.PP
\f[CR]XdrSrv\f[R] provides everything an RFC5531 RPC library needs to
marshal and unmarshal arguments.
The \f[CR]Do()\f[R] method of an \f[CR]XdrSrvProc\f[R] calls the
underlying method on \f[CR]My_vers_Server\f[R].
Hence, program\-independent RPC code can call
\f[CR]proc := GetProc()\f[R] to get the \f[CR]XdrSrvProc\f[R], then
unmarshal \f[CR]proc.GetArg()\f[R], then call \f[CR]proc.Do()\f[R] to
handle the call, and finally marshal the result from
\f[CR]proc.GetRes()\f[R].
.IP
.EX
\f[B]type\f[R] XdrSrvProc \f[B]interface\f[R] {
    XdrProc
    Do()
}

\f[B]type\f[R] XdrSrv \f[B]interface\f[R] {
    Prog() uint32
    Vers() uint32
    ProgName() string
    VersName() string
    GetProc(uint32) XdrSrvProc
}
.EE
.SH OPTIONS
goxdr supports the following options:
.TP
\f[CR]\-help\f[R]
Print a brief usage message.
.TP
\f[CR]\-b\f[R]
goxdr by default imports
\f[CR]\[dq]github.com/xdrpp/goxdr/xdr\[dq]\f[R], a module with
boilerplate code to assist in marshaling and unmarshaling values,
including code for interfaces such as \f[CR]XDR\f[R] and
\f[CR]XdrNum32\f[R] as well as helper types implementing these
interfaces (\f[CR]XdrInt32\f[R], \f[CR]XdrUint32\f[R], etc.).
This option suppresses that default import.
This can be useful if you are importing another package that includes
the boilerplate (see \f[CR]\-B\f[R]).
.TP
\f[CR]\-B\f[R]
Causes goxdr to emit the boilerplate into its output instead of
importing it.
Implies \f[CR]\-b\f[R].
Note only one copy of the boilerplate should be included in a package.
If you use goxdr to compile all XDR input files to a single go file (the
recommended usage), then you will get only one copy of the boilerplate
with \f[CR]\-B\f[R].
However, if you compile different XDR files into different go files, you
will need to specify \f[CR]\-b\f[R] with each XDR input file to avoid
including the boilerplate, then run goxdr with no input files
(\f[CR]goxdr \-B \-o goxdr_boilerplate.go\f[R]) to get one copy of the
boilerplate.
You should also use \f[CR]\-b\f[R] if you are importing another package
that already includes the boilerplate using the \f[CR]\-i\f[R] option
below.
.TP
\f[CR]\-enum\-comments\f[R]
When an enum has one or more constants annotated with a comment, this
options causes goxdr to emit a method
\f[CR]XdrEnumComments() map[int32]string\f[R] that contains the comment
turned into a string.
The option is useful if, for instance, you have an enum encoding various
error conditions.
In that case you can put a human\-readable description of the error
condition as a comment in the XDR source file, and access the text of
that comment from your program.
.TP
\f[CR]\-fmt\f[R]
Pass the generated code through \f[CR]gofmt \-s\f[R] to simplify and
format it.
.TP
\f[CR]\-i\f[R] \f[I]import_path\f[R]
Add the directive import .
\[lq]\f[I]import_path\f[R]\[rq] at the top of the output file.
This is needed when XDR files in the current package require XDR
structures defined in a different package, since XDR itself provides no
way to specify package scoping.
.TP
\f[CR]\-lax\-discriminants\f[R]
Cast all discriminants and cases (except bool) to int32, so that you can
use discriminants and cases that are different enum types.
.TP
\f[CR]\-o\f[R] \f[I]output.go\f[R]
Write the output to file \f[I]output.go\f[R] instead of standard output.
.TP
\f[CR]\-p\f[R] \f[I]package\f[R]
Specify the package name to use for the generated code.
The default is for the generated code to declare
\f[CR]package main\f[R].
.SH EXAMPLES
To serialize a data structure of type \f[CR]MyType\f[R]:
.IP
.EX
\f[B]func\f[R] serialize_Mytype(val *MyType) []byte {
    buf := &bytes.Buffer{}
    XDR_MyType(val).XdrMarshal(&XdrOut{ buf }, \[dq]\[dq])
    \f[B]return\f[R] buf.Bytes()
}
.EE
.PP
To serialize/unserialize an arbitrary instance of \f[CR]XdrType\f[R]:
.IP
.EX
\f[B]func\f[R] serialize(val XdrType) []byte {
    buf := &bytes.Buffer{}
    val.XdrMarshal(&XdrOut{ buf }, \[dq]\[dq])
    \f[B]return\f[R] buf.Bytes()
}

\f[B]func\f[R] deserialize(val XdrType, in []byte) (e error) {
    \f[B]defer\f[R] \f[B]func\f[R]() {
        \f[B]switch\f[R] i := recover().(\f[B]type\f[R]) {
        \f[B]case\f[R] nil:
        \f[B]case\f[R] XdrError:
            e = i
        \f[B]default\f[R]:
            panic(i)
        }
    }()
    val.XdrMarshal(&XdrIn{ bytes.NewBuffer(in) }, \[dq]\[dq])
    \f[B]return\f[R] nil
}
.EE
.PP
To pretty\-print an arbitrary XDR\-defined data structure, but
special\-case any fields of type \f[CR]MySpecialStruct\f[R] by
formatting them with a function called
\f[CR]MySpecialString(*MySpecialStruct)\f[R], you can do the following:
.IP
.EX
\f[B]type\f[R] XdrMyPrint \f[B]struct\f[R] {
    Out io.Writer
}

\f[B]func\f[R] (xp *XdrMyPrint) Sprintf(f string, args ...\f[B]interface\f[R]{}) string {
    \f[B]return\f[R] fmt.Sprintf(f, args...)
}

\f[B]func\f[R] (xp *XdrMyPrint) Marshal(name string, i XdrType) {
    \f[B]switch\f[R] v := i.(\f[B]type\f[R]) {
    \f[B]case\f[R] *MySpecialStruct:
        fmt.Fprintf(xp.Out, \[dq]%s: %s\[rs]n\[dq], name, MySpecialString(v))
    \f[B]case\f[R] fmt.Stringer:
        fmt.Fprintf(xp.Out, \[dq]%s: %s\[rs]n\[dq], name, v.String())
    \f[B]case\f[R] XdrPtr:
        fmt.Fprintf(xp.Out, \[dq]%s._present: %v\[rs]n\[dq], name, v.GetPresent())
        v.XdrMarshalValue(xp, name)
    \f[B]case\f[R] XdrVec:
        fmt.Fprintf(xp.Out, \[dq]%s.len: %d\[rs]n\[dq], name, v.GetVecLen())
        v.XdrMarshalN(xp, name, v.GetVecLen())
    \f[B]case\f[R] XdrAggregate:
        v.XdrRecurse(xp, name)
    \f[B]default\f[R]:
        fmt.Fprintf(xp.Out, \[dq]%s: %v\[rs]n\[dq], name, i)
    }
}

\f[B]func\f[R] MyXdrToString(t XdrType) string {
    out := &strings.Builder{}
    t.XdrMarshal(&XdrMyPrint{out}, \[dq]\[dq])
    \f[B]return\f[R] out.String()
}
.EE
.SH SEE ALSO
rpcgen(1), xdrc(1)
.PP
\c
.UR https://tools.ietf.org/html/rfc4506
.UE \c
, \c
.UR https://tools.ietf.org/html/rfc5531
.UE \c
.SH BUGS
goxdr is not hygienic.
Because it capitalizes symbols, it could produce a name clash if two
symbols differ only in the capitalization of the first letter.
Moreover, it introduces various helper types and functions that begin
\f[CR]XDR_\f[R] or \f[CR]Xdr\f[R], so could produce incorrect code if
users employ such identifiers in XDR files.
Though RFC4506 disallows identifiers that start with underscore, goxdr
accepts them and produces code with inconsistent export semantics (since
underscore cannot be capitalized).
.PP
With \f[CR]\-lax\-discriminants\f[R], when unions use type bool as a
discriminant, goxdr generates incorrect code unless it knows that the
discriminant is of type bool.
(This is because go provides no uniform syntax for converting both enums
and bools to int32.)
goxdr tries to figure out when the union discriminant is of type bool by
following typedefs in the file, but this doesn\[cq]t work if you use
type aliases defined in a different file.
.PP
IEEE 754 floating point allows for many different NaN (not a number)
values.
The marshaling code simply takes whatever binary value go has sitting in
memory, byteswapping on little\-endian machines.
Other languages and XDR implemenations may produce different NaN values
from the same code.
Hence, in the presence of floating point, the marshaled output of
seemingly deterministic code may vary across implementations.
.SH AUTHORS
David Mazières.
